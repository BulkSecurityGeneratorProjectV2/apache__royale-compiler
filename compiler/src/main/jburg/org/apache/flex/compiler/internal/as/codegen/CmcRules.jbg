/*
 *
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

/*
 *  CmcRules.jbg holds the rewrite rules that effect code generation
 *  from a CodeModel syntax tree.
 *  @see CmcPatterns.jbg, which holds the correspondings.
 */

/*
 *   ******************
 *   ** Declarations **
 *   ******************
 */

//  Prototype reduction logic for functions 
//  is in FunctionRules.jbg; include them with
//  thes for each variation.
@include "FunctionRules.jbg"
@include "FunctionRules.jbg" typelessFunction="typelessGetter" typedFunction="typedGetter"
@include "FunctionRules.jbg" typelessFunction="typelessSetter" typedFunction="typedSetter"

// anonymous function closure
expression = anonymousFunction: 1
@Prologue reducer.prologue_anonymousFunction(p)
@Reduction reducer.reduce_anonymousFunction(__p, function_body);

// typeless named function closure.
expression = typelessFunctionObject: 1
@Prologue reducer.prologue_functionObject(p)
@Reduction reducer.reduce_functionObject(__p, function_name, plist, null, block);

// named function closure with a return type.
expression = typedFunctionObject: 1
@Prologue reducer.prologue_functionObject(p)
@Reduction reducer.reduce_functionObject(__p, function_name, plist, return_type, block);

//  A typeless nested function.
statement = typelessFunction: 0
@Prologue reducer.prologue_typelessFunction_to_statement(p)
@Reduction reducer.reduce_typelessFunction(__p, plist, block);

//  A nested function with a return type.
statement = typedFunction: 0
@Prologue reducer.prologue_typedFunction_to_statement(p)
@Reduction reducer.reduce_typedFunction_to_statement(__p, plist, return_type, block);

/*
 *  A parameterList with parameters.
 */
parameterList = plist: 0 
@Reduction reducer.reduce_plist(__p, pdecl);

parameter = requiredParameter: 0
@Reduction reducer.reduce_requiredParameter(__p, param_name, param_type);

parameter = optionalParameter: 0
@Reduction reducer.reduce_optionalParameter(__p, param_name, param_type, default_value);

parameter = restParameter: 0
@Reduction reducer.reduce_restParameter (__p, param_name, param_type);

/*
 *  ******************
 *  **  Statements  **
 *  ******************
 */

/*
 *  Control-flow statements.
 */
statement = whileStmt: 0
@Prologue reducer.prologue_whileStmt(p)
@Reduction reducer.reduce_whileStmt(__p, cond, body);

statement = doStmt: 0
@Prologue reducer.prologue_doStmt(p)
@Reduction reducer.reduce_doStmt(__p, body, cond);

statement = countedForStmt: 2
@Prologue reducer.prologue_countedForStmt(p)
@Reduction reducer.reduce_countedForStmt(__p, init, test_insns, incr, body);

statement = forInStmt: 10
@Prologue reducer.prologue_forInStmt(p)
@Reduction reducer.reduce_forKeyValueStmt(__p, it, base, body, OP_nextname);

statement = forInArrayStmt: 10
@Prologue reducer.prologue_forInStmt(p)
@Reduction reducer.reduce_forKeyValueArrayStmt(__p, stem, index, base, body, OP_nextname, false);

statement = forInMemberStmt: 10
@Prologue reducer.prologue_forInStmt(p)
@Reduction reducer.reduce_forKeyValueMemberStmt(__p, stem, member, base, body, OP_nextname, false);

statement = forInDescendantStmt: 10
@Prologue reducer.prologue_forInStmt(p)
@Reduction reducer.reduce_forKeyValueMemberStmt(__p, stem, descendants, base, body, OP_nextname, false);

statement = forInSuperStmt: 10
@Prologue reducer.prologue_forInStmt(p)
@Reduction reducer.reduce_forKeyValueMemberStmt(__p, null, member, base, body, OP_nextname, true);

statement = forInSuperBracketStmt: 10
@Prologue reducer.prologue_forInStmt(p)
@Reduction reducer.reduce_forKeyValueArrayStmt(__p, null, index, base, body, OP_nextname, true);

statement = forVarDeclInStmt: 10
@Prologue reducer.prologue_forInStmt(p)
@Reduction reducer.reduce_forVarDeclInStmt(__p, single_decl, base, body, OP_nextname);

statement = forEachVarDeclInStmt: 10
@Prologue reducer.prologue_forInStmt(p)
@Reduction reducer.reduce_forVarDeclInStmt(__p, single_decl, base, body, OP_nextvalue);

statement = forEachStmt: 10
@Prologue reducer.prologue_forEachStmt(p)
@Reduction reducer.reduce_forKeyValueStmt(__p, it, base, body, OP_nextvalue);

statement = forEachArrayStmt: 10
@Prologue reducer.prologue_forEachStmt(p)
@Reduction reducer.reduce_forKeyValueArrayStmt(__p, stem, index, base, body, OP_nextvalue, false);

statement = forEachMemberStmt: 10
@Prologue reducer.prologue_forEachStmt(p)
@Reduction reducer.reduce_forKeyValueMemberStmt(__p, stem, member, base, body, OP_nextvalue, false);

statement = forEachInDescendantStmt: 10
@Prologue reducer.prologue_forInStmt(p)
@Reduction reducer.reduce_forKeyValueMemberStmt(__p, stem, descendants, base, body, OP_nextvalue, false);

statement = forEachSuperStmt: 10
@Prologue reducer.prologue_forEachStmt(p)
@Reduction reducer.reduce_forKeyValueMemberStmt(__p, null, member, base, body, OP_nextvalue, true);

statement = forEachSuperBracketStmt: 10
@Prologue reducer.prologue_forEachStmt(p)
@Reduction reducer.reduce_forKeyValueArrayStmt(__p, null, index, base, body, OP_nextvalue, true);

statement = ifElseIf: 0
@Reduction reducer.reduce_ifElseIf (__p, test, then, if_elseif);

conditionalElements = lastElse: 0
@Reduction reducer.reduce_lastElse(__p, else_clause);


/*
 *  General form of switch statement: expand into if/elseif.
 */
statement = switchStmt: 0
@Prologue reducer.prologue_switchStmt(p)
@Reduction reducer.reduce_switchStmt(__p, switch_expr, cases);

conditionalElements = switchCase: 0
@Reduction reducer.reduce_conditionalFragment(__p, case_expr, case_actions);

conditionalElements = constantSwitchCase: 0
@Reduction reducer.reduce_constantConditionalFragment(__p, case_const_value, case_actions);

conditionalElements = switchDefault: 0
@Reduction reducer.reduce_conditionalFragment(__p, null, case_actions);

statement = returnVoidSideEffect: 1
@Reduction reducer.reduce_returnVoidSideEffect(__p, expr);

statement = returnValue: 2
@Reduction reducer.reduce_returnValue(__p, value);

//  returnVoidValue's cost is inflated to cause
//  the code generator to prefer returnValue
//  whenever returnValue is feasible.  
//  Some reductions to void_expr are cheaper
//  than the corresponding reduction to expr,
//  so the CG thinks returning a void value
//  is a good choice in isolation.
statement = returnVoidValue: 2000
@Reduction reducer.reduce_returnVoidValue (__p, no_value);

statement = returnVoid: 1
@Reduction reducer.reduce_returnVoid(__p);

statement = returnNil: 1
@Reduction reducer.reduce_returnVoid(__p);

statement = breakStmt: 1
@Reduction reducer.reduce_breakStmt(__p);

statement = labeledBreakStmt: 0
@Reduction reducer.reduce_labeledBreakStmt(__p);

statement = continueStmt: 1
@Reduction reducer.reduce_continueStmt(__p);

statement = labeledContinueStmt: 0
@Reduction reducer.reduce_labeledContinueStmt(__p);

statement = gotoStmt: 1
@Reduction reducer.reduce_gotoStmt(__p);

//  CodeModel doesn't have an ExpressionStatement node,
//  so accept a bare expression as a statement.
statement = void_expression;

/*
 *  A block of statements.
 */
statement = blockStmt: 0
@Prologue reducer.prologue_blockStmt(p)
@Reduction reducer.reduce_blockStmt_to_statement(__p, stmts);

statement = configBlockStmt: 0
@Prologue reducer.prologue_blockStmt(p)
@Reduction reducer.reduce_blockStmt_to_statement(__p, stmts);

/*
 *  ********************
 *  **  Declarations  **
 *  ********************
 */
var_decl = typedVariableDecl: 0
@Reduction reducer.reduce_typedVariableDecl(__p, var_name, var_type, chained_decls);

var_decl = typedVariableDeclWithInitializer: 0
@Reduction reducer.reduce_typedVariableDeclWithInitializer(__p, var_name, var_type, var_initializer, chained_decls);

var_decl = typedVariableDeclWithConstantInitializer: 0
@Reduction reducer.reduce_typedVariableDeclWithConstantInitializer(__p, var_name, var_type, constant_var_initializer, chained_decls);

var_decl = typedBindableVariableDecl: 0
@Reduction reducer.reduce_typedBindableVariableDecl(__p, var_name, var_type, chained_decls);

var_decl = typedBindableVariableDeclWithInitializer: 0
@Reduction reducer.reduce_typedBindableVariableDeclWithInitializer(__p, var_name, var_type, var_initializer, chained_decls);

statement = var_decl;

statement = namespaceDeclaration: 0
@Reduction reducer.reduce_namespaceDeclaration (__p, ns_name);

statement = namespaceDeclarationConstantInitializer: 0
@Reduction reducer.reduce_namespaceDeclarationConstantInitializer (__p, ns_name, uri);

statement = namespaceDeclarationInitializer: 0
@Reduction reducer.reduce_namespaceDeclarationInitializer (__p, ns_name, second_ns);

/*
 *  ******************
 *  **  Exceptions  **
 *  ******************
 */

statement = throwStmt: 1
@Reduction reducer.reduce_throwStmt(__p, tossable);

statement = tryCatchStmt: 0
@Prologue reducer.prologue_tryCatchStmt(p)
@Reduction reducer.reduce_tryCatchStmt(__p, try_stmt, catch_blocks);

statement = tryFinallyStmt: 0
@Prologue reducer.prologue_tryFinallyStmt(p)
@Reduction reducer.reduce_tryFinallyStmt(__p, try_stmt, finally_stmt);

statement = tryCatchFinallyStmt: 0
@Prologue reducer.prologue_tryCatchFinallyStmt(p)
@Reduction reducer.reduce_tryCatchFinallyStmt(__p, try_stmt, finally_stmt, catch_blocks);

catch_block = catchBlockTyped: 0
@Prologue reducer.prologue_catchBlock(p)
@Reduction reducer.reduce_catchBlockTyped (__p, var_name, exception, action);

catch_block = catchBlockUntyped: 0
@Prologue reducer.prologue_catchBlock(p)
@Reduction reducer.reduce_catchBlockUntyped (__p, var_name, action);

finally_clause = blockStmt: 0
@Prologue reducer.prologue_blockStmt_to_finally_clause(p)
@Reduction reducer.reduce_blockStmt_to_finally_clause(__p, stmts);

statement = labeledStmt: 0
@Prologue reducer.prologue_labeledStmt(p)
@Reduction reducer.reduce_labeledStmt(__p, label, substatement);

//  with statement.
statement = withStmt: 0
@Prologue reducer.prologue_withStmt(p)
@Reduction reducer.reduce_withStmt(__p, new_scope, body);

/*
 *  *******************
 *  **  Expressions  **
 *  *******************
 */
void_expression = expression: 1
@Reduction reducer.transform_expression_to_void_expression(__p, expression);

/*
 *  Assignment to a simple name.
 */
void_expression = assignToNameExpr: 1
@Reduction reducer.reduce_assignToNameExpr_to_void_expression(__p, lval, r);

expression = assignToNameExpr: 2
@Reduction reducer.reduce_assignToNameExpr_to_expression(__p, lval,r);

/*
 *  Assignment to a more general lvalue.
 */
void_expression = assignToMemberExpr: 10
@Reduction reducer.reduce_assignToMemberExpr_to_void_expression(__p, stem, member, r);

expression = assignToMemberExpr: 10
@Reduction reducer.reduce_assignToMemberExpr_to_expression(__p, stem, member, r);

/*
 *  Assignment to a[i] type lvalue.
 */
void_expression = assignToBracketExpr: 1
@Reduction reducer.reduce_assignToBracketExpr_to_void_expression(__p, stem, index, r, false);

expression = assignToBracketExpr: 1
@Reduction reducer.reduce_assignToBracketExpr_to_expression(__p, stem, index, r, false);

void_expression = assignToSuperBracketExpr: 1
@Reduction reducer.reduce_assignToBracketExpr_to_void_expression(__p, null, index, r, true);

expression = assignToSuperBracketExpr: 1
@Reduction reducer.reduce_assignToBracketExpr_to_expression(__p, null, index, r, true);

/*
 *  Assignment to qualified names and attributes.
 */
void_expression = assignToQualifiedMemberExpr: 1
@Reduction reducer.reduce_assignToQualifiedMemberExpr(__p, stem, qualifier, member, r, DISCARD_VALUE);

expression = assignToQualifiedMemberExpr: 1
@Reduction reducer.reduce_assignToQualifiedMemberExpr(__p, stem, qualifier, member, r, NEED_VALUE);

void_expression = assignToQualifiedRuntimeMemberExpr: 1
@Reduction reducer.reduce_assignToQualifiedRuntimeMemberExpr(__p, stem, qualifier, member, r, DISCARD_VALUE);

expression = assignToQualifiedRuntimeMemberExpr: 1
@Reduction reducer.reduce_assignToQualifiedRuntimeMemberExpr(__p, stem, qualifier, member, r, NEED_VALUE);

void_expression = assignToQualifiedAttributeExpr: 1
@Reduction reducer.reduce_assignToQualifiedAttributeExpr(__p, stem, qualifier, attribute, r,DISCARD_VALUE);

expression = assignToQualifiedAttributeExpr: 1
@Reduction reducer.reduce_assignToQualifiedAttributeExpr(__p, stem, qualifier, attribute, r, NEED_VALUE);

void_expression = assignToQualifiedRuntimeAttributeExpr: 1
@Reduction reducer.reduce_assignToQualifiedRuntimeAttributeExpr(__p, stem, qualifier, attribute, r, DISCARD_VALUE);

void_expression = assignToQualifiedRuntimeAttributeExpr: 1
@Reduction reducer.reduce_assignToQualifiedRuntimeAttributeExpr(__p, stem, qualifier, attribute, r, NEED_VALUE);

void_expression = assignToUnqualifiedRuntimeAttributeExpr: 1
@Reduction reducer.reduce_assignToUnqualifiedRuntimeAttributeExpr(__p, stem, rt_attr_name, r, DISCARD_VALUE);

expression = assignToUnqualifiedRuntimeAttributeExpr: 1
@Reduction reducer.reduce_assignToUnqualifiedRuntimeAttributeExpr(__p, stem, rt_attr_name, r, NEED_VALUE);

// TODO: This is more than a smidge whacky but it's what ASC does.
// Research and pursue with PM.
void_expression = assignToUnqualifiedRuntimeDescendantsAttributeExpr: 1
@Reduction reducer.reduce_assignToUnqualifiedRuntimeAttributeExpr(__p, stem, rt_attr_name, r, DISCARD_VALUE);

expression = assignToUnqualifiedRuntimeDescendantsAttributeExpr: 1
@Reduction reducer.reduce_assignToUnqualifiedRuntimeAttributeExpr(__p, stem, rt_attr_name, r, NEED_VALUE);

/*
 *  Assignment to descendants.
 */
void_expression = assignToDescendantsExpr: 1
@Reduction reducer.reduce_assignToDescendantsExpr(__p, stem, member, r, DISCARD_VALUE);

expression = assignToDescendantsExpr: 1
@Reduction reducer.reduce_assignToDescendantsExpr(__p, stem, member, r, NEED_VALUE);

/*
 *  Error trap for diagnosing parser/CG mismatches.
 *  The cost is unfeasibly high for a normal reduction,
 *  so this will only be chosen if no other reduction works.
 */
expression = Op_AssignId(expression non_lvalue, expression rvalue ): ERROR_TRAP
@Reduction reducer.error_reduce_Op_AssignId(__p, non_lvalue, rvalue);

/*
 *  Compound assignment.
 */
@include "CompoundAssignmentRules.jbg" \
    opcode="OP_add" \
    compoundAssignToName="assignPlusToNameExpr" \
    compoundAssignToMember="assignPlusToMemberExpr" \
    compoundAssignToBracket="assignPlusToBracketExpr" \
    compoundAssignToDescendants="assignPlusToDescendantsExpr" \
    compoundAssignToRuntimeName="assignPlusToRuntimeNameExpr"

@include "CompoundAssignmentRules.jbg" \
    opcode="OP_subtract" \
    compoundAssignToName="assignMinusToNameExpr" \
    compoundAssignToMember="assignMinusToMemberExpr" \
    compoundAssignToBracket="assignMinusToBracketExpr" \
    compoundAssignToDescendants="assignMinusToDescendantsExpr" \
    compoundAssignToRuntimeName="assignMinusToRuntimeNameExpr"

@include "CompoundAssignmentRules.jbg" \
    opcode="OP_divide" \
    compoundAssignToName="assignDivideToNameExpr" \
    compoundAssignToMember="assignDivideToMemberExpr" \
    compoundAssignToBracket="assignDivideToBracketExpr" \
    compoundAssignToDescendants="assignDivideToDescendantsExpr" \
    compoundAssignToRuntimeName="assignDivideToRuntimeNameExpr"

@include "CompoundAssignmentRules.jbg" \
    opcode="OP_multiply" \
    compoundAssignToName="assignMultiplyToNameExpr" \
    compoundAssignToMember="assignMultiplyToMemberExpr" \
    compoundAssignToBracket="assignMultiplyToBracketExpr" \
    compoundAssignToDescendants="assignMultiplyToDescendantsExpr" \
    compoundAssignToRuntimeName="assignMultiplyToRuntimeNameExpr"

@include "CompoundAssignmentRules.jbg" \
    opcode="OP_modulo" \
    compoundAssignToName="assignModuloToNameExpr" \
    compoundAssignToMember="assignModuloToMemberExpr" \
    compoundAssignToBracket="assignModuloToBracketExpr" \
    compoundAssignToDescendants="assignModuloToDescendantsExpr" \
    compoundAssignToRuntimeName="assignModuloToRuntimeNameExpr"

@include "CompoundAssignmentRules.jbg" \
    opcode="OP_bitor" \
    compoundAssignToName="assignBitwiseOrToNameExpr" \
    compoundAssignToMember="assignBitwiseOrToMemberExpr" \
    compoundAssignToBracket="assignBitwiseOrToBracketExpr" \
    compoundAssignToDescendants="assignBitwiseOrToDescendantsExpr" \
    compoundAssignToRuntimeName="assignBitwiseOrToRuntimeNameExpr"

@include "CompoundAssignmentRules.jbg" \
    opcode="OP_bitand" \
    compoundAssignToName="assignBitwiseAndToNameExpr" \
    compoundAssignToMember="assignBitwiseAndToMemberExpr" \
    compoundAssignToBracket="assignBitwiseAndToBracketExpr" \
    compoundAssignToDescendants="assignBitwiseAndToDescendantsExpr" \
    compoundAssignToRuntimeName="assignBitwiseAndToRuntimeNameExpr"

@include "CompoundAssignmentRules.jbg" \
    opcode="OP_bitxor" \
    compoundAssignToName="assignBitwiseXorToNameExpr" \
    compoundAssignToMember="assignBitwiseXorToMemberExpr" \
    compoundAssignToBracket="assignBitwiseXorToBracketExpr" \
    compoundAssignToDescendants="assignBitwiseXorToDescendantsExpr" \
    compoundAssignToRuntimeName="assignBitwiseXorToRuntimeNameExpr"

@include "CompoundAssignmentRules.jbg" \
    opcode="OP_lshift" \
    compoundAssignToName="assignLeftShiftToNameExpr" \
    compoundAssignToMember="assignLeftShiftToMemberExpr" \
    compoundAssignToBracket="assignLeftShiftToBracketExpr" \
    compoundAssignToDescendants="assignLeftShiftToDescendantsExpr" \
    compoundAssignToRuntimeName="assignLeftShiftToRuntimeNameExpr"

@include "CompoundAssignmentRules.jbg" \
    opcode="OP_rshift" \
    compoundAssignToName="assignRightShiftToNameExpr" \
    compoundAssignToMember="assignRightShiftToMemberExpr" \
    compoundAssignToBracket="assignRightShiftToBracketExpr" \
    compoundAssignToDescendants="assignRightShiftToDescendantsExpr" \
    compoundAssignToRuntimeName="assignRightShiftToRuntimeNameExpr"

@include "CompoundAssignmentRules.jbg" \
    opcode="OP_urshift" \
    compoundAssignToName="assignUnsignedRightShiftToNameExpr" \
    compoundAssignToMember="assignUnsignedRightShiftToMemberExpr" \
    compoundAssignToBracket="assignUnsignedRightShiftToBracketExpr" \
    compoundAssignToDescendants="assignUnsignedRightShiftToDescendantsExpr" \
    compoundAssignToRuntimeName="assignUnsignedRightShiftToRuntimeNameExpr"

@include "CompoundLogicalAssignmentRules.jbg" \
    IsAnd="true" \
    compoundAssignToName="assignLogicalAndToNameExpr" \
    compoundAssignToMember="assignLogicalAndToMemberExpr" \
    compoundAssignToBracket="assignLogicalAndToBracketExpr" \
    compoundAssignToDescendants="assignLogicalAndToDescendantsExpr" \
    compoundAssignToRuntimeName="assignLogicalAndToRuntimeNameExpr"

@include "CompoundLogicalAssignmentRules.jbg" \
    IsAnd="false" \
    compoundAssignToName="assignLogicalOrToNameExpr" \
    compoundAssignToMember="assignLogicalOrToMemberExpr" \
    compoundAssignToBracket="assignLogicalOrToBracketExpr" \
    compoundAssignToDescendants="assignLogicalOrToDescendantsExpr" \
    compoundAssignToRuntimeName="assignLogicalOrToRuntimeNameExpr"


/* 
 *  Miscellaneous void expressions.
 */
void_expression = variableExpression: 0
@Reduction reducer.reduce_variableExpression (__p, decls);

void_expression = nilExpr: 0
@Reduction reducer.createInstructionList(__p);

expression = nilExpr: 1
@Reduction reducer.reduce_nilExpr_to_expression(__p);

void_expression = groupedVoidExpression: 0
@Reduction reducer.reduce_groupedVoidExpression(__p, contents);

/*
 *  Special Instruction List node - allows arbitrary instructions to be inserted
 *  where an expression is expected.  Used by some MXML processing that wants to
 *  generate code without having to create a synthetic AST to pass to the burm.
 */
expression = instructionListExpression: 1
@Reduction reducer.reduce_instructionListExpression(__p);

/*
 *  Binary logical operators.
 */
comparison_expression = equalExpr: 1 
@Reduction reducer.binaryOp (__p, l, r, OP_equals);

comparison_expression = neqExpr: 1 
@Reduction reducer.reduce_neqExpr (__p, l, r);

comparison_expression = stricteqExpr: 1 
@Reduction reducer.binaryOp (__p, l, r, OP_strictequals);

comparison_expression = strictneqExpr: 1 
@Reduction reducer.reduce_strictneqExpr (__p, l, r);

comparison_expression = greaterThanExpr: 1 
@Reduction reducer.binaryOp (__p, l, r, OP_greaterthan);

comparison_expression = greaterThanEqExpr: 1 
@Reduction reducer.binaryOp (__p, l, r, OP_greaterequals);

comparison_expression = lessExpr: 1 
@Reduction reducer.binaryOp (__p, l, r, OP_lessthan);

comparison_expression = lessEqExpr: 1 
@Reduction reducer.binaryOp (__p, l, r, OP_lessequals);

//  Closure rule: any comparison_expression
//  is also an expression without further conversion.
expression = comparison_expression;

expression = logicalAndExpr: 5
@Reduction reducer.reduce_logicalAndExpr (__p, l, r);

expression = logicalOrExpr: 5
@Reduction reducer.reduce_logicalOrExpr (__p, l, r);

expression = logicalNotExpr: 1
@Reduction reducer.reduce_logicalNotExpr (__p, expr);

expression = ternaryExpr: 1
@Reduction reducer.reduce_ternaryExpr (__p, test, when_true, when_false);

/*
 *  Binary branching constructs;
 *  not really operators, but kept
 *  near their equivalent operators
 *  for maintenance's sake.
 */
conditionalJump = equalExpr: 1 
@Reduction reducer.conditionalJump(__p, l, r, OP_ifeq);

conditionalJump = neqExpr: 1
@Reduction reducer.conditionalJump(__p, l, r, OP_ifne);

conditionalJump = stricteqExpr: 1 
@Reduction reducer.conditionalJump(__p, l, r, OP_ifstricteq);

conditionalJump = strictneqExpr: 1 
@Reduction reducer.conditionalJump(__p, l, r, OP_ifstrictne);

conditionalJump =  greaterThanExpr: 1 
@Reduction reducer.conditionalJump(__p, l, r, OP_ifgt);

conditionalJump =  greaterThanEqExpr: 1 
@Reduction reducer.conditionalJump(__p, l, r, OP_ifge);

conditionalJump = lessExpr: 1 
@Reduction reducer.conditionalJump(__p, l, r, OP_iflt);

conditionalJump = lessEqExpr: 1 
@Reduction reducer.conditionalJump(__p, l, r, OP_ifle);

conditionalJump = nilExpr: 1
@Reduction reducer.reduce_nilExpr_to_conditionalJump (__p);

/*
 *  General form of conditional jump.
 */
conditionalJump = expression: 1
@Reduction reducer.transform_expression_to_conditionalJump(__p, expression);

/*
 *  Binary arithmetic operators.
 */

expression = divideExpr: 1 
@Reduction reducer.binaryOp(__p, l, r, OP_divide);

expression = multExpr: 1 
@Reduction reducer.binaryOp(__p, l, r, OP_multiply);

expression = moduloExpr: 1 
@Reduction reducer.binaryOp(__p, l, r, OP_modulo);

expression = addExpr: 1 
@Reduction reducer.binaryOp(__p, l, r, OP_add);

expression = subtractExpr: 1 
@Reduction reducer.binaryOp(__p, l, r, OP_subtract);

expression = bitwiseLeftShiftExpr: 1 
@Reduction reducer.binaryOp(__p, l, r, OP_lshift);

expression = bitwiseRightShiftExpr: 1 
@Reduction reducer.binaryOp(__p, l, r, OP_rshift);

expression = bitwiseUnsignedRightShiftExpr: 1 
@Reduction reducer.binaryOp(__p, l, r, OP_urshift);

expression = bitwiseAndExpr: 1 
@Reduction reducer.binaryOp(__p, l, r, OP_bitand);

expression = bitwiseOrExpr: 1 
@Reduction reducer.binaryOp(__p, l, r, OP_bitor);

expression = bitwiseXorExpr: 1 
@Reduction reducer.binaryOp(__p, l, r, OP_bitxor);

/*
 *  pre/postfix unary operators.
 */

expression = postIncNameExpr: 7
@Reduction reducer.reduce_postIncNameExpr(__p, unary, true);

void_expression = postIncNameExpr: 7
@Reduction reducer.reduce_postIncNameExpr(__p, unary, false);

expression = preIncNameExpr: 7
@Reduction reducer.reduce_preIncNameExpr(__p, unary, true);

void_expression = preIncNameExpr: 7
@Reduction reducer.reduce_preIncNameExpr(__p, unary, false);

expression = preIncMemberExpr: 8
@Reduction reducer.reduce_preIncMemberExpr(__p, stem, field, true);

void_expression = preIncMemberExpr: 8
@Reduction reducer.reduce_preIncMemberExpr(__p, stem, field, false);

expression = postIncMemberExpr: 8
@Reduction reducer.reduce_postIncMemberExpr(__p, stem, field, true);

void_expression = postIncMemberExpr: 8
@Reduction reducer.reduce_postIncMemberExpr(__p, stem, field, false);

expression = preIncBracketExpr: 8
@Reduction reducer.reduce_preIncBracketExpr(__p, stem, index, true);

void_expression = preIncBracketExpr: 8
@Reduction reducer.reduce_preIncBracketExpr(__p, stem, index, false);

expression = postIncBracketExpr: 8
@Reduction reducer.reduce_postIncBracketExpr(__p, stem, index, true);

void_expression = postIncBracketExpr: 8
@Reduction reducer.reduce_postIncBracketExpr(__p, stem, index, false);

expression = postDecNameExpr: 7
@Reduction reducer.reduce_postDecNameExpr(__p, unary, true);

void_expression = postDecNameExpr: 7
@Reduction reducer.reduce_postDecNameExpr(__p, unary, false);

expression = preDecNameExpr: 7
@Reduction reducer.reduce_preDecNameExpr(__p, unary, true);

void_expression = preDecNameExpr: 7
@Reduction reducer.reduce_preDecNameExpr(__p, unary, false);

expression = preDecMemberExpr: 8
@Reduction reducer.reduce_preDecMemberExpr(__p, stem, field, true);

void_expression = preDecMemberExpr: 8
@Reduction reducer.reduce_preDecMemberExpr(__p, stem, field, false);

expression = postDecMemberExpr: 8
@Reduction reducer.reduce_postDecMemberExpr(__p, stem, field, true);

void_expression = postDecMemberExpr: 8
@Reduction reducer.reduce_postDecMemberExpr(__p, stem, field, false);

expression = preDecBracketExpr: 8
@Reduction reducer.reduce_preDecBracketExpr(__p, stem, index, true);

void_expression = preDecBracketExpr: 8
@Reduction reducer.reduce_preDecBracketExpr(__p, stem, index, false);

expression = postDecBracketExpr: 8
@Reduction reducer.reduce_postDecBracketExpr(__p, stem, index, true);

void_expression = postDecBracketExpr: 8
@Reduction reducer.reduce_postDecBracketExpr(__p, stem, index, false);



/*
 *  Unary expressions.
 */
expression = unaryMinusExpr: 1
@Reduction reducer.unaryOp(__p, e, OP_negate);

expression = unaryPlusExpr: 0
{
    return reducer.unaryOp(__p, e, reducer.op_unplus());
}

expression = typeofExpr: 10
@Prologue reducer.prologue_typeof(p)
@Reduction reducer.reduce_typeof_expr(__p, expr);

expression = typeofName: 1
@Prologue reducer.prologue_typeof(p)
@Reduction reducer.reduce_typeof_name(__p, n);

expression = bitNotExpr: 1
@Reduction reducer.unaryOp(__p, unary, OP_bitnot);

/*
 *  Miscellaneous binary expressions.
 */
expression = istypeExprLate: 1
@Reduction reducer.binaryOp(__p, expr, typename, OP_istypelate);

expression = astypeExprLate: 1
@Reduction reducer.binaryOp(__p, expr, typename, OP_astypelate);

expression = inExpr: 1
@Reduction reducer.binaryOp(__p, needle, haystack, OP_in);

expression = instanceofExpr: 1
@Reduction reducer.binaryOp(__p, expr, typename, OP_instanceof);

/*
 *  Primary expressions.
 */
expression = memberAccessExpr: 10
@Reduction reducer.reduce_memberAccessExpr (__p, stem, member, OP_getproperty);

expression =  qualifiedMemberAccessExpr: 10
@Reduction reducer.reduce_qualifiedMemberAccessExpr(__p, stem, qualifier, member, OP_getproperty);

expression =  qualifiedDescendantsExpr: 10
@Reduction reducer.reduce_qualifiedMemberAccessExpr(__p, stem, qualifier, member, OP_getdescendants);

expression = qualifiedDescendantsRuntimeExpr: 1
@Reduction reducer.reduce_qualifiedAttributeRuntimeMemberExpr(__p, stem, qualifier, runtime_member, OP_getdescendants);

expression = qualifiedAttributeExpr: 1
@Reduction reducer.reduce_qualifiedAttributeExpr(__p, stem, qualifier, member, OP_getproperty);

expression = qualifiedDescendantsAttributeExpr: 1
@Reduction reducer.reduce_qualifiedAttributeExpr(__p, stem, qualifier, member, OP_getdescendants);

expression = qualifiedAttributeRuntimeMemberExpr: 1
@Reduction reducer.reduce_qualifiedAttributeRuntimeMemberExpr(__p, stem, qualifier, runtime_member, OP_getproperty);

expression = qualifiedDescendantsRuntimeMemberExpr: 1
@Reduction reducer.reduce_qualifiedAttributeRuntimeMemberExpr(__p, stem, qualifier, runtime_member, OP_getdescendants);

//  Prefer the basic memberAccessExpr where feasible.
expression = qualifiedMemberRuntimeNameExpr: 100
@Reduction reducer.reduce_qualifiedMemberRuntimeNameExpr(__p, stem, qualifier, runtime_member);

expression = unqualifiedAttributeExpr: 1
@Reduction reducer.reduce_unqualifiedAttributeExpr(__p, stem, expr, OP_getproperty);

expression = unqualifiedDescendantsAttributeExpr: 1
@Reduction reducer.reduce_unqualifiedAttributeExpr(__p, stem, expr, OP_getdescendants);

expression = runtimeAttributeExp: 1
@Reduction reducer.reduce_runtimeAttributeExp(__p, expr);

expression = arrayIndexExpr: 1
@Reduction reducer.reduce_arrayIndexExpr (__p, stem, false, index);

expression = superIndexExpr: 1
@Reduction reducer.reduce_arrayIndexExpr (__p, null, true, index);

expression = functionCallExpr: 3  // Cost artificially inflated
@Reduction reducer.reduce_functionCallExpr_to_expression (__p, method_name, args);

//  Use callpropvoid to dodge a pop insn where it fits.
void_expression =  functionCallExpr: 2 
@Reduction reducer.reduce_functionCallExpr_to_void_expression (__p, method_name, args);

void_expression = superCallExpr: 2
@Reduction reducer.reduce_superCallExpr (__p, args);

void_expression = functionCallOfSuperclassMethod: 1 
@Reduction reducer.reduce_functionCallOfSuperclassMethod_to_void_expression (__p, null, method_name, args);

void_expression = functionCallOfExplicitObjectSuperclassMethod: 2
@Reduction reducer.reduce_functionCallOfSuperclassMethod_to_void_expression (__p, stem, method_name, args);

expression = newVectorLiteral: 0
@Reduction reducer.reduce_newVectorLiteral(__p, literal);

//  'new Array()' has cost 1.
expression = emptyConstructor: isEmptyArrayConstructor()
@Reduction reducer.reduce_newEmptyArray(__p);

//  'new Object()' has cost 1.
expression = emptyConstructor: isEmptyObjectConstructor()
@Reduction reducer.reduce_newEmptyObject(__p);

//  'new Whatever(...)' has cost 2, so it gets beaten by the two previous rules.
//  Use this reduction if the type is known;
//  it allows much better error checking of the constructor call.
expression = newExpr: 2
@Reduction reducer.reduce_newExpr (__p, class_binding, args);

expression = newMemberProperty: 10
@Reduction reducer.reduce_newMemberProperty(__p, stem, member, args);

expression = newAsRandomExpr: 30
@Reduction reducer.reduce_newAsRandomExpr (__p, random_expr, args);

expression = functionCallOfSuperclassMethod: 2
@Reduction reducer.reduce_functionCallOfSuperclassMethod_to_expression (__p, null, method_name, args);

expression = functionCallOfExplicitObjectSuperclassMethod: 2
@Reduction reducer.reduce_functionCallOfSuperclassMethod_to_expression (__p, stem, method_name, args);

expression = functionAsMemberExpr: 4  //  Cost inflated to prefer functionCallOfSuperclassMethod
@Reduction reducer.reduce_functionAsMemberExpr (__p, stem, method_name, args);

expression = functionAsBracketExpr: 4
@Reduction reducer.reduce_functionAsBracketExpr (__p, stem, index, args);

expression = functionAsRandomExpr: 30
@Reduction reducer.reduce_functionAsRandomExpr (__p, random_expr, args);

/*
 *  Delete expressions.
 */
expression = deleteNameExpr: 2
@Reduction reducer.reduce_deleteNameExpr(__p, n);

expression = deleteBracketExpr: 1
@Reduction reducer.reduce_deleteBracketExpr(__p, stem, index);

expression = deleteAtBracketExpr: 1
@Reduction reducer.reduce_deleteAtBracketExpr(__p, stem, index);

expression = deleteMemberExpr: 1
@Reduction reducer.reduce_deleteMemberExpr(__p, stem, field);

expression = deleteRuntimeNameExpr: 1
@Reduction reducer.reduce_deleteRuntimeNameExpr(__p, stem, rt_name);

expression = deleteDescendantsExpr: 1
@Reduction reducer.reduce_deleteDescendantsExpr(__p, stem, field);

expression = deleteAnyExprExprExpr: 2000
@Reduction reducer.reduce_deleteExprExprExpr(__p, expr);

/*
 *  Comma expression.
 */
expression = commaExpr: 0
@Reduction reducer.reduce_commaExpr(__p, payload_expr, exprs);

/*
 *  Names and reference expressions built from names.
 */
name = simpleName: 0
@Reduction reducer.reduce_simpleName (__p);

decl_name = simpleName: 0
@Reduction reducer.reduce_declName(__p);

qualifiedNamePart = simpleName: 0
@Reduction reducer.getIdentifierContent(__p);

name = typedVariableExpression: 0
@Reduction reducer.reduce_typedVariableExpression (__p, var_name, var_type);

dottedNamePart = dottedName: 0
@Reduction reducer.reduce_by_concatenation (__p, first, second);

dottedNamePart = qualifiedNamePart;

name = dottedName: isDottedName()
@Reduction reducer.dottedName (__p, first, second);

name = dottedName: isPackageName()
@Reduction reducer.errorPackageName(__p, first, second);

//  This reduction handles an entire dotted name subtree.
name = fullName: 0
@Reduction reducer.dottedName(__p, first, second);

//  qualified namespace is the same as a full name,
//  it's just what gets produced when we're in a use namespace directive
//     use namespace a.b.Foo;
name = qualifiedNamespaceName: 0
@Reduction reducer.dottedName(__p, first, second);

//  This reduction handles the bar.T part of foo.bar.T
dottedNamePart = fullName: 0
@Reduction reducer.reduce_by_concatenation (__p, first, second);

name = superAccess: 0
@Reduction reducer.reduce_superAccess (__p, qualified_name);

name = superThisAccess: isSuperThisForFieldAccess()
@Reduction reducer.reduce_superAccess (__p, qualified_name);

//  A bare parameterized type name can only be
//  used as a type annotation.  In code it's necessary
//  to expand it into an expression that calls applytype.
type_name = parameterizedName :0
@Reduction reducer.reduce_parameterizedName (__p, base, param);

//  A name can be a type_name, which in combination with
//  the reduction above yields the set of possible type_names:
//  identifiers and *
type_name = name: 1
@Reduction reducer.reduce_nameToTypeName(name, true);

//  The 'new' expression takes a pseduo-type name:
//  when it can be resolved, the semantic analysis
//  code can check the constructor.  When it can't 
//  be resolved, it fails at runtime.
new_type_name = name;

//  Inflate this cost so it's only selected
//  if the type_name isn't a name.
new_type_name = type_name: 20
@Reduction reducer.reduce_nameToTypeName(type_name, false);

// Special rule to convert from name to type param expression
// we need this because '*' converts special in this context
type_param_expression = name: 1
@Reduction reducer.reduce_typeNameParameter(__p, name);

// any other expression can be used as a type param name in an expression context
type_param_expression = expression;

expression = parameterizedTypeExpression: 1
@Reduction reducer.reduce_parameterizedTypeExpression (__p, base, param);

expression = name: 2000
@Reduction reducer.transform_name_to_expression(__p, name);

type_name = voidExpr: 0
@Reduction reducer.reduce_voidExpr_to_type_name(__p);

name = attributeName: 0
@Reduction reducer.reduce_attributeName (__p, attr_name);

//  ns1::foo and rt_ns::foo look alike to 
//  the parser, so they must be disambiguated
//  by checking their semantic annotations.
name = namespaceAccess: qualifierIsCompileTimeConstant()
@Reduction reducer.reduce_namespaceAccess (__p, qualifier, qualified_name);

//  Error trap for an unresolved namespace in a context
//  where it must be declared.
name = namespaceAccess: ERROR_TRAP
@Reduction reducer.error_namespaceAccess(__p, qualifier, qualified_name);

//  A namespace-qualified name reference whose name
//  is a runtime expression, e.g., ns1::[foo].
//  The parser doesn't know the difference between
//  ns1::[foo] and rt_ns::[foo], so we need a cost
//  function to disambiguate the tree.
runtime_name_expression = namespaceMultinameL: qualifierIsCompileTimeConstant()
@Reduction reducer.reduce_namespaceMultinameL(__p, qualifier, expr);

runtime_name_expression = namespaceRTQName: 2000
@Reduction reducer.reduce_namespaceRTQName (__p, qualifier, qualfied_name);

expression = embedExpression: 2
@Reduction reducer.reduce_embed(__p);

/*
 *  E4X expressions (except literals)
 */

expression = e4xFilter: 3
@Reduction reducer.reduce_e4xFilter (__p, stem, filter);

runtime_name_expression = namespaceRTQNameL: 2000
@Reduction reducer.reduce_namespaceRTQNameL (__p, qualifier, expr);

expression = runtime_name_expression: 1
@Reduction reducer.transform_runtime_name_expression(__p, runtime_name_expression);

expression = runtimeNameExpression: 1
@Reduction reducer.reduce_runtimeNameExpression(__p, expr);

name = namespaceAsName: 1
@Reduction reducer.reduce_namespaceAsName_to_name(__p);

expression = namespaceAsName: 1
@Reduction reducer.reduce_namespaceAsName_to_expression(__p);

void_expression = assignToRuntimeNameExpr: 1
@Reduction reducer.reduce_assignToRuntimeNameExpr(__p, lval, r, DISCARD_VALUE);

expression = assignToRuntimeNameExpr: 1
@Reduction reducer.reduce_assignToRuntimeNameExpr(__p, lval, r, NEED_VALUE);

expression = descendantsExpression: 1
@Reduction reducer.reduce_memberAccessExpr(__p, stem, descendants, OP_getdescendants);

/*
 *  E4X directives and statements
 */
statement = defaultXMLNamespace: 1
@Reduction reducer.reduce_defaultXMLNamespace(__p, ns_expr);

/*
 *  Literals.
 */
e4x_literal = XMLLiteral: 0
@Reduction reducer.getStringLiteralContent (__p);

string_constant = e4x_literal;

expression = XMLContent: 1
@Reduction reducer.reduce_XMLContent(__p, exprs);

expression = XMLList: 2
@Reduction reducer.reduce_XMLList(__p, exprs);

expression = XMLListConst: 1
@Reduction reducer.reduce_XMLListConst(__p, elements);

expression = literal;
literal = object_literal;
literal = boolean_literal;
literal = array_literal;

expression = string_constant: 1
@Reduction reducer.transform_string_constant(__p, string_constant);

integer_constant = integerLiteral: 0
@Reduction reducer.getIntegerContent(__p);

expression = integer_constant: 1
@Reduction reducer.transform_integer_constant(__p, integer_constant);

uint_constant = uintLiteral: 0
@Reduction reducer.getUintContent(__p);

expression = uint_constant: 1
@Reduction reducer.transform_uint_constant(__p, uint_constant);

expression = boolean_constant: 1
@Reduction reducer.transform_boolean_constant(__p, boolean_constant);


/**
 * Constant values
 */

//  Constant-folded arithmetic for all types.
@include "ConstantArithmetic.jbg"

//  Constant-folded logic for all types
@include "ConstantLogic.jbg"

//  Error trap for non-constant expressions
//  used in a context where only a constant is valid,
//  e.g., foo() in function needsConstantInit(x = foo()).
required_constant_value = expression: ERROR_TRAP
@Reduction reducer.transform_expression_to_constant_value(__p, expression);

//  A name can be used as a constant in some contexts,
//  e.g., if it's a Namespace or otherwise known to be
//  a compile-time constant.
constant_value = name: isCompileTimeConstant()
@Reduction reducer.transform_name_to_constant_value(__p);

constant_value = constantDottedName: isCompileTimeConstant()
@Reduction reducer.transform_name_to_constant_value(__p);

double_constant =  doubleLiteral: 3
@Reduction reducer.getDoubleContent(__p);

integer_constant = LiteralIntegerZeroID(void): 1
@Reduction reducer.getIntegerZeroContent(__p);

uint_constant = LiteralIntegerZeroID(void): 1
@Reduction reducer.getIntegerZeroContentAsLong(__p);

constant_value = nullLiteral: 0
@Reduction reducer.reduce_nullLiteral_to_constant_value (__p);

constant_value =  void0Literal: 0
@Reduction reducer.reduce_void0Literal_to_constant_value(__p);

constant_value =  voidConstant: 0
@Reduction reducer.reduce_voidOperator_to_constant_value(__p, value);

boolean_constant = booleanLiteral: 0
@Reduction reducer.reduce_booleanLiteral(__p);

string_constant = stringLiteral: 0
@Reduction reducer.getStringLiteralContent (__p);

numeric_constant = integer_constant;
numeric_constant = uint_constant;
numeric_constant = double_constant;


constant_value = string_constant: 1
@Reduction reducer.transform_string_constant_to_constant(__p, string_constant);

constant_value = boolean_constant: 1
@Reduction reducer.transform_boolean_constant_to_constant(__p, boolean_constant);

constant_value = numeric_constant: 1
@Reduction reducer.transform_numeric_constant_to_constant(__p, numeric_constant);

required_constant_value = constant_value;

//  Fallback code-gen choice if conversion to
//  double failed in LiteralNumberNode.getNodeID().
//  It's not likely to work better here,
//  but the BURM will emit some diagnostics.
double_constant =  numericLiteral: 3
@Reduction reducer.getDoubleContent(__p);

expression = double_constant: 5
@Reduction reducer.transform_double_constant(__p, double_constant);

expression = numeric_constant: 5
@Reduction reducer.transform_numeric_constant(__p, numeric_constant);

expression = constant_value: 0
@Reduction reducer.transform_constant_value(__p, constant_value);

object_literal = nullLiteral: 1
@Reduction reducer.reduce_nullLiteral_to_object_literal (__p);

object_literal = objectLiteral: 3
@Reduction reducer.reduce_objectLiteral (__p, elements);

object_literal_element = objectLiteralElement: 0
@Reduction reducer.reduce_objectLiteralElement (__p, id, value);

non_resolving_identifier = nonResolvingIdentifier: 0
@Reduction reducer.getIdentifierContent(__p);

expression = non_resolving_identifier: 1
@Reduction reducer.transform_non_resolving_identifier(__p, non_resolving_identifier);

object_literal = regexLiteral: 5
@Reduction reducer.reduce_regexLiteral(__p);

object_literal = void0Literal: 1
@Reduction reducer.reduce_void0Literal_to_object_literal(__p);

object_literal = void0Operator: 1
@Reduction reducer.reduce_void0Operator(__p);

expression = voidOperator: 1
@Reduction reducer.reduce_voidOperator_to_expression (__p, expr);

expression = voidExpr: 1
@Reduction reducer.reduce_voidExpr_to_expression(__p);

boolean_literal = boolean_constant: 1
@Reduction reducer.transform_boolean_constant(__p, boolean_constant);

array_literal = arrayLiteral: 1
@Reduction reducer.reduce_arrayLiteral (__p, elements);

vector_literal = vectorLiteral: 1
@Reduction reducer.reduce_vectorLiteral(__p, type_param, elements);

/*
 *  Directives.
 */
statement = useNamespaceDirective: 0
@Reduction reducer.reduce_useNamespaceDirective(__p, ns_name);

import_name = simpleName: 0
@Reduction reducer.createInstructionList(__p);

import_name = fullName: 0
@Reduction reducer.createInstructionList(__p);

statement = importDirective: 0
@Reduction reducer.reduce_importDirective(__p);

/*
 *  MXML constructs
 */

function = mxmlEventSpecifier: 0
@Prologue reducer.prologue_mxmlEventSpecifier(p)
@Reduction reducer.reduce_mxmlEventSpecifier (__p, stmts);


// MXML data binding setter expression's
//
// mxml_data_binding_setter_expression is in effect
// an alternate start symbol that is never reachable from a
// rule that is reachable from any other start symbol.
// The mxml_data_binding_setter_expression is used
// as the goal state when this BURM is invoked from
// AbcGenerator.generateMXMLDataBindingSetterFunction.
mxml_data_binding_setter_expression = memberAccessExpr: 1
@Reduction reducer.reduce_memberAccessExpr_to_mxmlDataBindingSetter(__p, stem, member);

mxml_data_binding_setter_expression =  qualifiedMemberAccessExpr: 10
@Reduction reducer.reduce_qualifiedMemberAccessExpr_to_mxmlDataBindingSetter(__p, stem, qualifier, member);

mxml_data_binding_setter_expression = qualifiedMemberRuntimeNameExpr: 100
@Reduction reducer.reduce_qualifiedMemberRuntimeNameExpr_to_mxmlDataBindingSetter(__p, stem, qualifier, runtime_member);

mxml_data_binding_setter_expression = arrayIndexExpr: 1
@Reduction reducer.reduce_arrayIndexExpr_to_mxmlDataBindingSetter(__p, stem, index, false);

mxml_data_binding_setter_expression = name: 1
@Reduction reducer.reduceName_to_mxmlDataBindingSetter(__p, name);

mxml_data_binding_setter_expression = runtime_name_expression: 1
@Reduction reducer.reduceRuntimeName_to_mxmlDataBindingSetter(__p, runtime_name_expression);
